import java.io.FileReader;
import java.util.ArrayList;
import java.util.Collections;
import java.io.IOException;


public class Parser {

    private final LexicalAnalyzer lexer;
    private Symbol token;
    private LexicalUnit tokenLexUnit;
    private ArrayList<Integer> derivationList;

    public Parser(FileReader source){
        lexer = new LexicalAnalyzer(source);
    }

    /**
     * Selects the next token matched by the lexer
     * and stores its type (Lexical Unit) in tokenLexUnit
     */
    private void nextToken(){
        try{
            token = lexer.nextToken();
            tokenLexUnit = token.getType();
        }
        catch(IOException e){
            e.printStackTrace();
        }
    }

    /**
     * Verifies if the matched lexical unit corresponds
     * to the expected one. If not, an error is raised.
     * @param expected (the expected lexical unit)
     * @return the root of a ParseTree
     */
    private ParseTree matchTest(LexicalUnit expected){
        if(!(tokenLexUnit.equals(expected))){
            syntaxError(token, expected);
        }
        return new ParseTree(token);
    }

    /**
     * Starts the parsing, initialize the parseTree.
     * Once the parsing is finished, it prints the left most derivation
     * @return the parsing tree of the leftmost derivation
     */
    private ParseTree startParsing(){
        ParseTree parseTree = PROGRAM();
        System.out.println(derivationList.toString());
        return parseTree;
    }

    /** // Modifier la java doc
     * Parse the <Program> rule
     * @return the ParseTree generated by the derivation
     */
    private ParseTree PROGRAM(){
        ArrayList<ParseTree> children = new ArrayList<>();
        nextToken();
        switch (tokenLexUnit) {
            case BEG:
                derivationList.add(1);
                children.add(matchTest(LexicalUnit.BEG));
                nextToken();
                children.add(CODE());
                nextToken();
                children.add(matchTest(LexicalUnit.END));
                break;
        
            default:
                syntaxError(token, LexicalUnit.BEG);
                break;
        }
        return new ParseTree(new Symbol("PROGRAM"), children);
    }

    private ParseTree CODE(){
        ArrayList<ParseTree> children = new ArrayList<>();
        switch (tokenLexUnit) {
            case IF:
            case BEG:
            case WHILE:
            case PRINT:
            case READ:
            case VARNAME:
                derivationList.add(3);
                children.add(INSTLIST());
                break;

            case END:
                derivationList.add(2);
                children.add(new ParseTree(new Symbol("$\\varepsilon$")));
                break;
            default:
                ArrayList<String> expected_list = new ArrayList<>();
                Collections.addAll(expected_list, "BEG", "WHILE", "PRINT", "READ", "VARNAME", "END"); 
                syntaxError(token, expected_list);
                break;
        }
    }


    /**
     * Launches an error and exits the code. 
     * @param token the token that generated the error.
     */
    private void syntaxError(Symbol token, LexicalUnit expected){
        System.err.println("Syntax Error occured when reading the token : " + token.getValue()+" at line : " + token.getLine()+". Lexical Unit(s) "+expected+"was expected, but "+token.getType()+"was found." );
        System.exit(1);
    }



    /**
     * Launches an error and exits the code. 
     * @param token the token that generated the error.
     */
    private void syntaxError(Symbol token, ArrayList<String> expected){
        System.err.println("Syntax Error occured when reading the token : " + token.getValue()+" at line : " + token.getLine()+". Lexical Unit(s) "+expected+"was expected, but "+token.getType()+"was found." );
        System.exit(1);
    }

}